{"version":3,"sources":["bluetooth.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;EAuBE;;AAEF,6CAA+C;AAC/C,qCAA2C;AAC3C,uCAA2C;AAC3C,uCAAkD;AAmElD;;GAEG;AACH,eAAuB,SAAQ,4BAAe;IAiB1C;;;OAGG;IACH,YAAY,OAA0B;QAClC,KAAK,EAAE,CAAC;QATJ,gBAAW,GAA+D,IAAI,CAAC;QAC/E,aAAQ,GAAW,KAAK,GAAG,IAAI,CAAC;QAChC,YAAO,GAAG,IAAI,CAAC;QASnB,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC;YAAC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC;QAE9D,iBAAO,CAAC,EAAE,CAAC,sBAAY,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE;YAC3C,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,kBAAkB,EAAE,KAAK,CAAC,CAAC;QAC5D,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,YAAY,CAAC,OAA6B,EAAE,UAAU,EAAE,aAAa;QACzE,IAAI,KAAK,GAAG,KAAK,CAAC;QAElB,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YAC7B,OAAO;YACP,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI,CAAC;gBAAC,MAAM,CAAC;YAE3D,aAAa;YACb,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC;oBAAC,MAAM,CAAC;gBAClF,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,KAAK,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;oBAAC,MAAM,CAAC;YAC1F,CAAC;YAED,WAAW;YACX,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAClB,MAAM,YAAY,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,wBAAc,CAAC,CAAC;gBACzD,MAAM,aAAa,GAAG,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;oBACnD,MAAM,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAChE,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC;oBAAC,MAAM,CAAC;gBAC3B,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;YACvD,CAAC;YAED,KAAK,GAAG,IAAI,CAAC;QACjB,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QACzB,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAED;;;OAGG;IACI,eAAe;QAClB,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,EAAE;YACpC,iBAAO,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;gBACzB,OAAO,CAAC,OAAO,CAAC,CAAC;YACrB,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;OAIG;IACI,aAAa,CAAC,OAA8B;QAC/C,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACnC,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;YAExB,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC;gBAAC,MAAM,CAAC,MAAM,CAAC,0CAA0C,CAAC,CAAC;YAErF,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;gBACjD,qBAAqB;gBACrB,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;oBACnD,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,2CAA2C,CAAC,CAAC,CAAC;gBAC9E,CAAC;gBAED,4BAA4B;gBAC5B,MAAM,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;oBAC9C,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;gBAC9C,CAAC,CAAC,CAAC;gBACH,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;oBACd,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,6CAA6C,CAAC,CAAC,CAAC;gBAChF,CAAC;gBAED,+BAA+B;gBAC/B,MAAM,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;oBAC9C,MAAM,CAAC,CAAC,OAAO,MAAM,CAAC,UAAU,KAAK,WAAW,IAAI,MAAM,CAAC,UAAU,KAAK,EAAE,CAAC,CAAC;gBAClF,CAAC,CAAC,CAAC;gBACH,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;oBACd,MAAM,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC,iDAAiD,CAAC,CAAC,CAAC;gBACpF,CAAC;YACL,CAAC;YAED,IAAI,WAAW,GAAG,EAAE,CAAC;YAErB,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;gBAClB,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;oBAC7B,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;wBAAC,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,wBAAc,CAAC,CAAC,CAAC;gBAC/F,CAAC,CAAC,CAAC;YACP,CAAC;YAED,aAAa;YACb,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE;gBACpD,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC;YACzC,CAAC,CAAC,CAAC;YAEH,IAAI,KAAK,GAAG,KAAK,CAAC;YAClB,iBAAO,CAAC,SAAS,CAAC,WAAW,EAAE,UAAU,CAAC,EAAE;gBACxC,IAAI,aAAa,GAAG,EAAE,CAAC;gBAEvB,kBAAkB,eAAe;oBAC7B,IAAI,CAAC,aAAa,EAAE;yBACnB,IAAI,CAAC,GAAG,EAAE;wBACP,OAAO,CAAC,eAAe,CAAC,CAAC;oBAC7B,CAAC,CAAC,CAAC;gBACP,CAAC;gBAED,sCAAsC;gBACtC,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;oBAClB,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,aAAa,CAAC,CAAC;gBACvE,CAAC;gBAED,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;oBACb,KAAK,GAAG,IAAI,CAAC;oBAEb,0BAA0B;oBAC1B,EAAE,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC;wBAC3B,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC,wBAAc,CAAC,CAAC,CAAC;oBACvF,CAAC;oBAED,sCAAsC;oBACtC,MAAM,eAAe,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE;wBAChE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC;oBACzC,CAAC,CAAC,CAAC;oBACH,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE;wBACtB,UAAU,EAAE,IAAI;wBAChB,gBAAgB,EAAE,eAAe;qBACpC,CAAC,CAAC;oBAEH,MAAM,eAAe,GAAG,IAAI,wBAAe,CAAC,UAAU,CAAC,CAAC;oBAExD;wBACI,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;oBACzC,CAAC;oBAED,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;wBACvF,gGAAgG;wBAChG,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;oBACzC,CAAC;gBACL,CAAC;YACL,CAAC,EAAE,GAAG,EAAE;gBACJ,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;oBAC3B,IAAI,CAAC,aAAa,EAAE;yBACnB,IAAI,CAAC,GAAG,EAAE;wBACP,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;4BAAC,MAAM,CAAC,uCAAuC,CAAC,CAAC;oBAChE,CAAC,CAAC,CAAC;gBACP,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YACtB,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,wBAAwB,KAAK,EAAE,CAAC,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACI,aAAa;QAChB,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,EAAE;YACpC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;gBACf,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;gBACpB,iBAAO,CAAC,QAAQ,EAAE,CAAC;YACvB,CAAC;YACD,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;;AA7LD;;;GAGG;AACW,4BAAkB,GAAW,qBAAqB,CAAC;AANrE,8BAgMC","file":"bluetooth.js","sourcesContent":["/*\n* Node Web Bluetooth\n* Copyright (c) 2017 Rob Moran\n*\n* The MIT License (MIT)\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventDispatcher } from \"./dispatcher\";\nimport { BluetoothDevice } from \"./device\";\nimport { getServiceUUID } from \"./helpers\";\nimport { adapter, NobleAdapter } from \"./adapter\";\n\n/**\n * Bluetooth Options interface\n */\nexport interface BluetoothOptions {\n    /**\n     * A `device found` callback function to allow the user to select a device\n     */\n    deviceFound?: (device: BluetoothDevice, selectFn: () => void) => boolean;\n\n    /**\n     * The amount of seconds to scan for the device (default is 10)\n     */\n    scanTime?: number;\n\n    /**\n     * An optional referring device\n     */\n    referringDevice?: BluetoothDevice;\n}\n\n/**\n * BluetoothLE Scan Filter Init interface\n */\nexport interface BluetoothLEScanFilterInit {\n    /**\n     * An array of service UUIDs to filter on\n     */\n    services?: Array<string | number>;\n\n    /**\n     * The device name to filter on\n     */\n    name?: string;\n\n    /**\n     * The device name prefix to filter on\n     */\n    namePrefix?: string;\n\n    // Maps unsigned shorts to BluetoothDataFilters.\n    // object manufacturerData;\n    // Maps BluetoothServiceUUIDs to BluetoothDataFilters.\n    // object serviceData;\n}\n\n/**\n * Request Device Options interface\n */\nexport interface RequestDeviceOptions {\n    /**\n     * An array of device filters to match\n     */\n    filters?: Array<BluetoothLEScanFilterInit>;\n\n    /**\n     * An array of optional services to have access to\n     */\n    optionalServices?: Array<string | number>;\n\n    /**\n     * Whether to accept all devices\n     */\n    acceptAllDevices?: boolean;\n}\n\n/**\n * Bluetooth class\n */\nexport class Bluetooth extends EventDispatcher {\n\n    /**\n     * Bluetooth Availability Changed event\n     * @event\n     */\n    public static EVENT_AVAILABILITY: string = \"availabilitychanged\";\n\n    /**\n     * Referring device for the bluetooth instance\n     */\n    public readonly referringDevice?: BluetoothDevice;\n\n    private deviceFound: (device: BluetoothDevice, selectFn: () => void) => boolean = null;\n    private scanTime: number = 10.24 * 1000;\n    private scanner = null;\n\n    /**\n     * Bluetooth constructor\n     * @param options Bluetooth initialisation options\n     */\n    constructor(options?: BluetoothOptions) {\n        super();\n\n        options = options || {};\n        this.referringDevice = options.referringDevice;\n        this.deviceFound = options.deviceFound;\n        if (options.scanTime) this.scanTime = options.scanTime * 1000;\n\n        adapter.on(NobleAdapter.EVENT_ENABLED, value => {\n            this.dispatchEvent(Bluetooth.EVENT_AVAILABILITY, value);\n        });\n    }\n\n    private filterDevice(options: RequestDeviceOptions, deviceInfo, validServices) {\n        let valid = false;\n\n        options.filters.forEach(filter => {\n            // Name\n            if (filter.name && filter.name !== deviceInfo.name) return;\n\n            // NamePrefix\n            if (filter.namePrefix) {\n                if (!deviceInfo.name || filter.namePrefix.length > deviceInfo.name.length) return;\n                if (filter.namePrefix !== deviceInfo.name.substr(0, filter.namePrefix.length)) return;\n            }\n\n            // Services\n            if (filter.services) {\n                const serviceUUIDs = filter.services.map(getServiceUUID);\n                const servicesValid = serviceUUIDs.every(serviceUUID => {\n                    return (deviceInfo._serviceUUIDs.indexOf(serviceUUID) > -1);\n                });\n\n                if (!servicesValid) return;\n                validServices = validServices.concat(serviceUUIDs);\n            }\n\n            valid = true;\n        });\n\n        if (!valid) return false;\n        return deviceInfo;\n    }\n\n    /**\n     * Gets the availability of a bluetooth adapter\n     * @returns Promise containing a flag indicating bluetooth availability\n     */\n    public getAvailability(): Promise<boolean> {\n        return new Promise((resolve, _reject) => {\n            adapter.getEnabled(enabled => {\n                resolve(enabled);\n            });\n        });\n    }\n\n    /**\n     * Scans for a device matching optional filters\n     * @param options The options to use when scanning\n     * @returns Promise containing a device which matches the options\n     */\n    public requestDevice(options?: RequestDeviceOptions): Promise<BluetoothDevice> {\n        return new Promise((resolve, reject) => {\n            options = options || {};\n\n            if (this.scanner !== null) return reject(\"requestDevice error: request in progress\");\n\n            if (!options.acceptAllDevices && !this.deviceFound) {\n                // Must have a filter\n                if (!options.filters || options.filters.length === 0) {\n                    return reject(new TypeError(\"requestDevice error: no filters specified\"));\n                }\n\n                // Don't allow empty filters\n                const emptyFilter = options.filters.some(filter => {\n                    return (Object.keys(filter).length === 0);\n                });\n                if (emptyFilter) {\n                    return reject(new TypeError(\"requestDevice error: empty filter specified\"));\n                }\n\n                // Don't allow empty namePrefix\n                const emptyPrefix = options.filters.some(filter => {\n                    return (typeof filter.namePrefix !== \"undefined\" && filter.namePrefix === \"\");\n                });\n                if (emptyPrefix) {\n                    return reject(new TypeError(\"requestDevice error: empty namePrefix specified\"));\n                }\n            }\n\n            let searchUUIDs = [];\n\n            if (options.filters) {\n                options.filters.forEach(filter => {\n                    if (filter.services) searchUUIDs = searchUUIDs.concat(filter.services.map(getServiceUUID));\n                });\n            }\n\n            // Unique-ify\n            searchUUIDs = searchUUIDs.filter((item, index, array) => {\n                return array.indexOf(item) === index;\n            });\n\n            let found = false;\n            adapter.startScan(searchUUIDs, deviceInfo => {\n                let validServices = [];\n\n                function complete(bluetoothDevice) {\n                    this.cancelRequest()\n                    .then(() => {\n                        resolve(bluetoothDevice);\n                    });\n                }\n\n                // filter devices if filters specified\n                if (options.filters) {\n                    deviceInfo = this.filterDevice(options, deviceInfo, validServices);\n                }\n\n                if (deviceInfo) {\n                    found = true;\n\n                    // Add additional services\n                    if (options.optionalServices) {\n                        validServices = validServices.concat(options.optionalServices.map(getServiceUUID));\n                    }\n\n                    // Set unique list of allowed services\n                    const allowedServices = validServices.filter((item, index, array) => {\n                        return array.indexOf(item) === index;\n                    });\n                    Object.assign(deviceInfo, {\n                        _bluetooth: this,\n                        _allowedServices: allowedServices\n                    });\n\n                    const bluetoothDevice = new BluetoothDevice(deviceInfo);\n\n                    function selectFn() {\n                        complete.call(this, bluetoothDevice);\n                    }\n\n                    if (!this.deviceFound || this.deviceFound(bluetoothDevice, selectFn.bind(this)) === true) {\n                        // If no deviceFound function, or deviceFound returns true, resolve with this device immediately\n                        complete.call(this, bluetoothDevice);\n                    }\n                }\n            }, () => {\n                this.scanner = setTimeout(() => {\n                    this.cancelRequest()\n                    .then(() => {\n                        if (!found) reject(\"requestDevice error: no devices found\");\n                    });\n                }, this.scanTime);\n            }, error => reject(`requestDevice error: ${error}`));\n        });\n    }\n\n    /**\n     * Cancels the scan for devices\n     */\n    public cancelRequest(): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            if (this.scanner) {\n                clearTimeout(this.scanner);\n                this.scanner = null;\n                adapter.stopScan();\n            }\n            resolve();\n        });\n    }\n}\n"],"sourceRoot":"../src"}